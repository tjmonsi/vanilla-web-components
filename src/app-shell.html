

<script>
  (() => {
    class AppShell extends HTMLElement {
      static get is() {
        return 'app-shell'
      }

      constructor() {
        super();
        this.pages = [];
        for (var i = 0; i < this.children.length; i++ ) {
          this.pages.push(this.children[i])
        }
        this.__boundGlobalOnClick = this._globalOnClick.bind(this);
      }

      connectedCallback() {
        window.document.body.addEventListener('click', this.__boundGlobalOnClick);
        this.urlChanged();
      }

      disconnectedCallback() {
        window.document.body.removeEventListener('click', this.__boundGlobalOnClick);
      }

      urlChanged () {
        this.path = window.decodeURIComponent(window.location.pathname);
        var patternMatched = null;
        var currentPage = 0;

        for (var k in this.pages) {
          this.pages[k].classList.remove('page-selected')
        }

        for (var i in this.pages) {
          currentPage = i;
          var pattern = this.pages[i].getAttribute('route');
          var patternPieces = pattern.split('/');
          var patternLength = patternPieces[patternPieces.length - 1] === '' ? patternPieces.length - 1 : patternPieces.length;
          var remainingPieces = this.path.split('/');
          var pathLength = remainingPieces[remainingPieces.length - 1] === '' ? remainingPieces.length - 1 : remainingPieces.length
          var routeMatched = []
          var namedMatches = {}

          // does the match making if the path length and pattern length is the same
          // or if the last part of the pattern is a *
          if ((pathLength === patternLength) || patternPieces[patternPieces.length - 1] === '*') {
            for (var j = 0; j < patternPieces.length; j++) {
              var patternPiece = patternPieces[j]
              
              // stops if the pattern piece is not existing
              if (!patternPiece && patternPiece !== '') {
                break
              }

              // get the left side of the path.
              var pathPiece = remainingPieces.shift()

              // stops if the left side doesn't exist
              if (!pathPiece && pathPiece !== '') {
                break
              }

              // push the current pattern to the route matched
              routeMatched.push(patternPiece)

              // if it has a ':', it means that the value in the current path fragment
              // should be put in the variable that has the name after the ':'
              if (patternPiece.charAt(0) === ':') {
                namedMatches[patternPiece.slice(1)] = pathPiece

              // if it is a '*', it means that it should accept all paths that has
              // a prefix of the route matched
              } else if (patternPiece === '*') {
                patternMatched = routeMatched.join('/')

              // the pattern piece and the path piece doesn't match, go to next route pattern
              } else if (patternPiece !== pathPiece) {
                break
              }

              // create the pattern matched
              patternMatched = routeMatched.join('/')
            }

            // if pattern matched is created, stop searching and change views
            if (patternMatched) {
              break
            }
          }
        }
        
        if (this.pages[currentPage].getAttribute('route') === patternMatched) {
          this.pages[currentPage].classList.add('page-selected')

          for (var j in namedMatches) {
            this.pages[currentPage][j] = namedMatches[j]
            // this.pages[currentPage].innerHTML = this.pages[currentPage].innerHTML.replace(new RegExp(':' + j, 'g'), namedMatches[j])
          }
        }
      }

      _globalOnClick(event) {
        // If another event handler has stopped this event then there's nothing
        // for us to do. This can happen e.g. when there are multiple
        // iron-location elements in a page.
        if (event.defaultPrevented) {
          return;
        }
        var href = this._getSameOriginLinkHref(event);
        if (!href) {
          return;
        }
        event.preventDefault();

        // If the navigation is to the current page we shouldn't add a history
        // entry or fire a change event.
        if (href === window.location.href) {
          return;
        }
        window.history.pushState({}, '', href);
        this.urlChanged();
      }

      _getSameOriginLinkHref(event) {
        // We only care about left-clicks.
        if (event.button !== 0) {
          return null;
        }

        // We don't want modified clicks, where the intent is to open the page
        // in a new tab.
        if (event.metaKey || event.ctrlKey) {
          return null;
        }

        // http://stackoverflow.com/questions/39245488/event-path-undefined-with-firefox-and-vue-js
        var eventPath = event.path || (event.composedPath && event.composedPath());
        var anchor = null;
        for (var i = 0; i < eventPath.length; i++) {
          var element = eventPath[i];
          if (element.tagName === 'A' && element.href) {
            anchor = element;
            break;
          }
        }

        // If there's no link there's nothing to do.
        if (!anchor) {
          return null;
        }

        // Target blank is a new tab, don't intercept.
        if (anchor.target === '_blank') {
          return null;
        }

        // If the link is for an existing parent frame, don't intercept.
        if ((anchor.target === '_top' ||
            anchor.target === '_parent') &&
            window.top !== window) {
          return null;
        }
        var href = anchor.href;

        // It only makes sense for us to intercept same-origin navigations.
        // pushState/replaceState don't work with cross-origin links.
        var url;
        if (window.document.baseURI != null) {
          url = new URL(href, /** @type {string} */(window.document.baseURI));
        } else {
          url = new URL(href);
        }
        var origin;

        // IE Polyfill
        if (window.location.origin) {
          origin = window.location.origin;
        } else {
          origin = window.location.protocol + '//' + window.location.hostname;
          if (window.location.port) {
            origin += ':' + window.location.port;
          }
        }
        if (url.origin !== origin) {
          return null;
        }
        var normalizedHref = url.pathname + url.search + url.hash;

        // If we've been configured not to handle this url... don't handle it!
        if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
          return null;
        }
        // Need to use a full URL in case the containing page has a base URI.
        var fullNormalizedHref = new URL(normalizedHref, window.location.href).href;
        return fullNormalizedHref;
      }


    }

    window.customElements.define(AppShell.is, AppShell)
  })()
</script>
